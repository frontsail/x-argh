{
  "version": 3,
  "sources": ["../src/index.js", "../src/cdn.js"],
  "sourcesContent": ["export default function (Alpine) {\n  Alpine.directive('argh', (el, { value, modifiers, expression }, { effect, evaluateLater }) => {\n    if (!value) {\n      return\n    }\n\n    let { argObj, argName, deep } = resolve(el._x_dataStack, expression)\n    const propObj = el._x_dataStack[0]\n    const propName = camelize(value)\n    const evaluator = argObj ? null : evaluateLater(expression)\n    const bind = argObj && modifiers.includes('bind')\n\n    let prevPropValue = propObj[propName]\n    let prevArgValue = undefined\n\n    effect(() => {\n      deep && ({ argObj, argName, deep } = resolve(el._x_dataStack, expression))\n\n      if (argObj) {\n        // One-way binding\n        if (argObj[argName] !== prevArgValue) {\n          propObj[propName] = argObj[argName]\n        }\n\n        // Two-way binding\n        if (bind && propObj[propName] !== prevPropValue) {\n          argObj[argName] = propObj[propName]\n        }\n\n        prevArgValue = argObj[argName]\n        prevPropValue = propObj[propName]\n      } else {\n        // The evaluator is used in case that the argument is not a property\n        // of the parent component data (one-way binding).\n        evaluator((argValue) => {\n          if (argValue !== prevArgValue) {\n            propObj[propName] = argValue\n            prevArgValue = argValue\n          }\n        })\n      }\n    })\n  })\n\n  function camelize(s) {\n    return s.replace(/-./g, (x) => x[1].toUpperCase())\n  }\n\n  function resolve(stack, expression) {\n    let argObj = null\n    let argName = null\n    let deep = false\n\n    for (let i = 1; i < stack.length; i++) {\n      if (expression in stack[i]) {\n        argObj = stack[i]\n        argName = expression\n        break\n      } else if (expression.includes('.')) {\n        const dotNotation = expression.split('.')\n        const obj = dotNotation\n          .slice(0, -1)\n          .reduce((o, i) => (typeof o === 'object' ? o[i] : false), stack[i])\n\n        if (obj) {\n          const name = dotNotation.slice(-1)\n\n          if (name in obj) {\n            argObj = obj\n            argName = name[0]\n            deep = obj !== stack[i]\n            break\n          }\n        }\n      }\n    }\n\n    return { argObj, argName, deep }\n  }\n}\n", "import xArgh from './'\n\ndocument.addEventListener('alpine:init', () => window.Alpine.plugin(xArgh))\n"],
  "mappings": "MAAe,WAAU,EAAQ,CAC/B,EAAO,UAAU,OAAQ,CAAC,EAAI,CAAE,QAAO,YAAW,cAAc,CAAE,SAAQ,mBAAoB,CAC5F,GAAI,CAAC,EACH,OAGF,GAAI,CAAE,SAAQ,UAAS,QAAS,EAAQ,EAAG,aAAc,GACnD,EAAU,EAAG,aAAa,GAC1B,EAAW,EAAS,GACpB,EAAY,EAAS,KAAO,EAAc,GAC1C,EAAO,GAAU,EAAU,SAAS,QAEtC,EAAgB,EAAQ,GACxB,EAEJ,EAAO,IAAM,CACX,GAAS,EAAE,SAAQ,UAAS,QAAS,EAAQ,EAAG,aAAc,IAE9D,AAAI,EAEE,GAAO,KAAa,GACtB,GAAQ,GAAY,EAAO,IAIzB,GAAQ,EAAQ,KAAc,GAChC,GAAO,GAAW,EAAQ,IAG5B,EAAe,EAAO,GACtB,EAAgB,EAAQ,IAIxB,EAAU,AAAC,GAAa,CACtB,AAAI,IAAa,GACf,GAAQ,GAAY,EACpB,EAAe,SAOzB,WAAkB,EAAG,CACnB,MAAO,GAAE,QAAQ,MAAO,AAAC,GAAM,EAAE,GAAG,eAGtC,WAAiB,EAAO,EAAY,CAClC,GAAI,GAAS,KACT,EAAU,KACV,EAAO,GAEX,OAAS,GAAI,EAAG,EAAI,EAAM,OAAQ,IAChC,GAAI,IAAc,GAAM,GAAI,CAC1B,EAAS,EAAM,GACf,EAAU,EACV,cACS,EAAW,SAAS,KAAM,CACnC,GAAM,GAAc,EAAW,MAAM,KAC/B,EAAM,EACT,MAAM,EAAG,IACT,OAAO,CAAC,EAAG,IAAO,MAAO,IAAM,SAAW,EAAE,GAAK,GAAQ,EAAM,IAElE,GAAI,EAAK,CACP,GAAM,GAAO,EAAY,MAAM,IAE/B,GAAI,IAAQ,GAAK,CACf,EAAS,EACT,EAAU,EAAK,GACf,EAAO,IAAQ,EAAM,GACrB,QAMR,MAAO,CAAE,SAAQ,UAAS,SC3E9B,SAAS,iBAAiB,cAAe,IAAM,OAAO,OAAO,OAAO",
  "names": []
}
